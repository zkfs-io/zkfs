"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[370],{6741:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(7462),o=(a(7294),a(3905));const i={title:"Introducing ZKFS, Mina's native data availability layer",slug:"introducing-zkfs-mina-data-availability-layer",authors:["maht0rz"],hide_table_of_contents:!1},r=void 0,s={permalink:"/blog/introducing-zkfs-mina-data-availability-layer",source:"@site/blog/2023-03-06-introducing-zkfs.md",title:"Introducing ZKFS, Mina's native data availability layer",description:"Introducing ZKFS _(Zero-Knowledge File System)_ - a data availability layer designed to reduce blockchain storage requirements while still allowing for complex business logic.",date:"2023-03-06T00:00:00.000Z",formattedDate:"March 6, 2023",tags:[],readingTime:10.425,hasTruncateMarker:!0,authors:[{name:"Matej Sima",title:"ZKFS Protocol Developer, Co-Founder @ Stove Labs",url:"https://github.com/maht0rz",imageURL:"https://github.com/maht0rz.png",key:"maht0rz"}],frontMatter:{title:"Introducing ZKFS, Mina's native data availability layer",slug:"introducing-zkfs-mina-data-availability-layer",authors:["maht0rz"],hide_table_of_contents:!1}},l={authorsImageUrls:[void 0]},p=[{value:"Why do we need a data availability layer at all?",id:"why-do-we-need-a-data-availability-layer-at-all",level:2},{value:"State of ZKFS development today",id:"state-of-zkfs-development-today",level:2},{value:"Architecture and fundamental principles",id:"architecture-and-fundamental-principles",level:2},{value:"Interchangable component overview",id:"interchangable-component-overview",level:3},{value:"Flow diagram &amp; Separation of responsibilities",id:"flow-diagram--separation-of-responsibilities",level:3},{value:"Using ZKFS in smart contracts",id:"using-zkfs-in-smart-contracts",level:2},{value:"Counter example",id:"counter-example",level:3},{value:"Transactions with off-chain state",id:"transactions-with-off-chain-state",level:3},{value:"Cryptographic guarantees and working principles",id:"cryptographic-guarantees-and-working-principles",level:3},{value:"Contract root map and <code>OffchainStateContract</code>",id:"contract-root-map-and-offchainstatecontract",level:4},{value:"Defining off-chain state",id:"defining-off-chain-state",level:4},{value:"Deploying contracts &amp; setting data",id:"deploying-contracts--setting-data",level:4},{value:"Reading data in contract methods",id:"reading-data-in-contract-methods",level:4},{value:"Nested map API",id:"nested-map-api",level:3},{value:"What can you expect in the near future?",id:"what-can-you-expect-in-the-near-future",level:2}],c={toc:p},d="wrapper";function h(t){let{components:e,...a}=t;return(0,o.kt)(d,(0,n.Z)({},c,a,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Introducing ZKFS ",(0,o.kt)("em",{parentName:"strong"},"(Zero-Knowledge File System)")," - a data availability layer designed to reduce blockchain storage requirements while still allowing for complex business logic. ")),(0,o.kt)("p",null,"Unlike traditional blockchain designs, MINA's zero-knowledge approach enables developers to store ",(0,o.kt)("sup",{parentName:"p",id:"fnref-1-912e90"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1-912e90",className:"footnote-ref"},"1")),"large data structures indirectly (through state hash commitments) without adding unnecessary bulk to the network. More importantly, it shifts the responsibilities of executing smart-contracts to the client side, together with delegating the data storage requirements outside of the MINA chain itself."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://zkfs.io"},"You can try ZKFS out for yourself on our online playground or locally.")),(0,o.kt)("p",null,"Our solution offers a suite of smart-contract libraries, networking utilities, and data consensus tools that allow for the seamless development of smart contracts capable of storing arbitrarily large data structures."),(0,o.kt)("h2",{id:"why-do-we-need-a-data-availability-layer-at-all"},"Why do we need a data availability layer at all?"),(0,o.kt)("p",null,'In the case of "traditional" smart-contract blockchain designs like EVM/Ethereum or Tezos, the business logic of each transaction and its smart contracts are validated directly by the chain itself. To include a smart contract transaction in a block, ',(0,o.kt)("strong",{parentName:"p"},'the block producer and all other nodes must have access to all the data related to the contract and the other "chain data"')," as well. This results in the blockchain growing in size, and ",(0,o.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/nodes-and-clients/archive-nodes/#hardware"},"for instance, an Ethereum archive node requires 3-12TB of storage space")," to run."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Thanks to the zero-knowledge nature of MINA and the well-designed smart-contract platform, operating a MINA node is expected to be less storage-intensive.")," This is especially true when scaling the amount of storage space used to accommodate the deployment of various applications/smart-contracts on the MINA platform."),(0,o.kt)("p",null,"The MINA network imposes a limitation on the amount of storage space that can be taken per account, allowing only 8 Fields. As a point of reference, a simple public key can be serialized into two Fields, meaning that each account or smart-contract can only store 4 public keys in its on-chain storage. While this restriction may benefit the network and its node operators by maintaining lower storage requirements compared to other blockchains, it presents a challenge for smart-contract development, as complex business logic often requires the storage of arbitrarily large data structures."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"To address this limitation, we have started working on ZKFS")," - a solution that provides an intuitive approach for developing smart contracts capable of storing arbitrarily large data structures. ZKFS offers a seamless developer experience, featuring a suite of (snarkyjs-based) libraries, zk-security guarantees, and networking utilities (ZKFS nodes) such as distributed data storage and replication, as well as data validation through built-in consensus mechanisms."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"state-of-zkfs-development-today"},"State of ZKFS development today"),(0,o.kt)("p",null,"In February we have begun working on a grant by the Mina Foundation to kickstart the development of ZKFS. This proposal is the next natural step in our journey to make ZKFS the go-to storage solution for MINA's smart-contract developers."),(0,o.kt)("p",null,"Based on our ",(0,o.kt)("a",{parentName:"p",href:"https://stove-labs.notion.site/Off-chain-Storage-74a69774288d4b3b80e861a8f10ff73a"},"initial ideation"),", we have originally split up the existing ZKFS roadmap into 4 milestones, the first two overall milestones are a part of the existing grant and are mostly done and available today."),(0,o.kt)("p",null,"First two milestones are pending further review by MF, after the target completion date by the end of March 2023."),(0,o.kt)("h2",{id:"architecture-and-fundamental-principles"},"Architecture and fundamental principles"),(0,o.kt)("p",null,"At it's core ZKFS is designed to be feature-permissive, with replacable components/adapters as per the ",(0,o.kt)("em",{parentName:"p"},"'substitution principle'"),". You can think of ZKFS as a shell, designed to run concrete implementations of its core components."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Don't like reading tables? Skip ahead to ",(0,o.kt)("a",{parentName:"p",href:"#separation-of-responsibilities-and-conceptual-flow"},"the flow diagram"),".")),(0,o.kt)("h3",{id:"interchangable-component-overview"},"Interchangable component overview"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"left"},"Component"),(0,o.kt)("th",{parentName:"tr",align:"left"},"Responsibilities"),(0,o.kt)("th",{parentName:"tr",align:"left"},"Available Implementations"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("strong",{parentName:"td"},"Node and Light Client")),(0,o.kt)("td",{parentName:"tr",align:"left"},"\u2014"),(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("a",{parentName:"td",href:"https://github.com/zkfs-io/zkfs/tree/feat/zkfs-node/packages/node"},"@zkfs/node"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"Storage"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Storing, replicating and validating incoming data through consensus"),(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("a",{parentName:"td",href:"https://github.com/zkfs-io/zkfs/tree/feat/zkfs-node/packages/storage-adapters/orbit-db"},"@zkfs/storage-orbit-db"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"Consensus"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Validating individual data writes per the desired consensus logic"),(0,o.kt)("td",{parentName:"tr",align:"left"},"[WIP]"," On-chain root hash consensus")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"Services"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Extending the features available in the ZKFS Node, currently used to provide access to data for light clients"),(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("a",{parentName:"td",href:"https://github.com/zkfs-io/zkfs/tree/feat/zkfs-node/packages/services/orbit-db-data-pubsub"},"@zkfs/orbit-db-data-pubsub"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"Event parser (working name)"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Observing and processing write requests made by the contracts"),(0,o.kt)("td",{parentName:"tr",align:"left"},"[WIP]"," Mina node transaction event parser")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"\u2014"),(0,o.kt)("td",{parentName:"tr",align:"left"},"\u2014"),(0,o.kt)("td",{parentName:"tr",align:"left"},"\u2014")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("strong",{parentName:"td"},"Contract tooling")),(0,o.kt)("td",{parentName:"tr",align:"left"},"\u2014"),(0,o.kt)("td",{parentName:"tr",align:"left"},"\u2014")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"Contract API"),(0,o.kt)("td",{parentName:"tr",align:"left"},"In-contract utilities with full SnarkyJS compatibility, verifying data retrieved from nodes/light clients, emitting data to be processed by nodes"),(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("a",{parentName:"td",href:"https://www.npmjs.com/package/@zkfs/contract-api"},"@zkfs/contract-api"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"Virtual storage"),(0,o.kt)("td",{parentName:"tr",align:"left"},"Virtual/rolling storage used to process in-memory data writes, required to ensure data correctness across multiple data writes"),(0,o.kt)("td",{parentName:"tr",align:"left"},(0,o.kt)("a",{parentName:"td",href:"https://www.npmjs.com/package/@zkfs/virtual-storage"},"@zkfs/virtual-storage"))))),(0,o.kt)("h3",{id:"flow-diagram--separation-of-responsibilities"},"Flow diagram & Separation of responsibilities"),(0,o.kt)("iframe",{width:"100%",height:"450",src:"https://www.figma.com/embed?embed_host=share&url=https%3A%2F%2Fwww.figma.com%2Ffile%2FyuquvCH4kOGTgh0zPXrHEh%2FUntitled%3Fnode-id%3D0%253A1%26t%3DuvoP6lTxmpk1uaC8-1",allowfullscreen:!0}),(0,o.kt)("h2",{id:"using-zkfs-in-smart-contracts"},"Using ZKFS in smart contracts"),(0,o.kt)("p",null,"Earlier we have described what components make ZKFS possible, now we'll dive into how exactly can a Mina smart contract ",(0,o.kt)("del",{parentName:"p"},"trust")," verify the data it receives from ZKFS."),(0,o.kt)("p",null,"Contract API comes with a set of utilities that make consuming off-chain state in a smart contract a breeze. First of all, it lets you define the shape and structure of your off-chain state,\nin a fashion very similiar to on-chain state. This ensures a low learning curve for existing SnarkyJS developers."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"Having trouble running any of the code snippets below? We keep our reference examples up to date, you can ",(0,o.kt)("a",{parentName:"p",href:"https://stackblitz.com/github/zkfs-io/zkfs?file=packages%2Fexamples%2Ftest%2Fcounter.test.ts,packages%2Fexamples%2Ftest%2Fcounter.ts&hideExplorer=1&hideNavigation=1&theme=dark&view=editor"},"try them in our online playground"),"."),(0,o.kt)("p",{parentName:"admonition"},"Examples in this blog post are valid under the following package releases:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@zkfs/contract-api@0.1.9-develop.151")))),(0,o.kt)("h3",{id:"counter-example"},"Counter example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="counter.ts" showLineNumbers',title:'"counter.ts"',showLineNumbers:!0},"import {\n  OffchainStateContract,\n  offchainState,\n  OffchainState,\n} from '@zkfs/contract-api';\n\nimport { UInt64 } from 'snarkyjs';\n\nclass Counter extends OffchainStateContract {\n  // badum-tss, we now have access to off-chain state\n  @offchainState() public count = OffchainState.fromRoot<UInt64>(UInt64);\n\n  // runs every time this contract is deployed\n  public init() {\n    super.init();\n    // initialise our 'count' state to 0\n    this.count.set(UInt64.from(0));\n  }\n\n  // anyone can call this method to increment the counter\n  @method\n  public update() {\n    // obtain 'count' from the off-chain state\n    const currentCount = this.count.get();\n    // increment the counter\n    const newCount = currentCount.add(1);\n    // set the new count off-chain state\n    this.count.set(newCount);\n  }\n}\n")),(0,o.kt)("br",null),(0,o.kt)("h3",{id:"transactions-with-off-chain-state"},"Transactions with off-chain state"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Is that it?")," Well not exactly... you still have to actually go and fetch the off-chain state required for your contract to run. This can be done by wrapping your contract transaction into ",(0,o.kt)("inlineCode",{parentName:"p"},"contractApi.transaction(...)"),", instead of using ",(0,o.kt)("inlineCode",{parentName:"p"},"Mina.transaction(...)")," directly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="counter.test.ts" showLineNumbers',title:'"counter.test.ts"',showLineNumbers:!0},"it('should update the counter', async () => {\n  const senderKey = PrivateKey.random();\n  const senderAccount = senderKey.toPublicKey();\n  // setup Contract API\n  const contractApi = new ContractApi();\n  // instance of the Counter contract\n  const zkApp = new Counter();\n\n  // Contract API automatically deducts with off-chain keys to fetch\n  const tx = await contractApi.transaction(zkApp, senderAccount, () => {\n    zkApp.update();\n  });\n\n  await tx.prove();\n  await tx.sign([senderKey]).send();\n});\n")),(0,o.kt)("br",null),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Please keep in mind that the example above works for simple contracts such as the Counter. If your contract relies\non more complext data structures - e.g. if you use our nested map API, then you might be required to specify what data to fetch\nfor each contract method manually."),(0,o.kt)("p",{parentName:"admonition"},"This isn't the target solution, there's a way to determine what keys and merkle maps need to be pre-fetched automatically, but its always\nup to the developer to consider the performance trade offs of both approaches."),(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"We'll ship automated key/map pre-fetching in the coming releases of the Contract API."))),(0,o.kt)("h3",{id:"cryptographic-guarantees-and-working-principles"},"Cryptographic guarantees and working principles"),(0,o.kt)("p",null,"Contract API is cool, but what actually happens when you ",(0,o.kt)("inlineCode",{parentName:"p"},".get()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},".set()")," state? Let's take a look at how Count's off-chain state data ends up being represented in the ZKFS network & tooling."),(0,o.kt)("h4",{id:"contract-root-map-and-offchainstatecontract"},"Contract root map and ",(0,o.kt)("inlineCode",{parentName:"h4"},"OffchainStateContract")),(0,o.kt)("p",null,"Each contract has a single corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"root map"),", which is an instance of SnarkyJS's ",(0,o.kt)("inlineCode",{parentName:"p"},"MerkleMap"),". By extending the ",(0,o.kt)("inlineCode",{parentName:"p"},"OffchainStateContract")," in your ",(0,o.kt)("inlineCode",{parentName:"p"},"Counter"),", you gain access to what Contract API has to offer. Firstly this means defining an on-chain ",(0,o.kt)("inlineCode",{parentName:"p"},"@state()")," for the root map's ",(0,o.kt)("inlineCode",{parentName:"p"},"offchainStateRootHash"),". This piece of on-chain state is the root has of your off-chain state root map. No other on-chain data is required for your contract to be compatible with ZKFS."),(0,o.kt)("h4",{id:"defining-off-chain-state"},"Defining off-chain state"),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," is a piece of off-chain state that resides directly on the root map itself. We know it is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"UInt64")," which is important for both receving data inside a contract, and for emitting new data through events. Data that can be stored in merkle maps, including the root map, must be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"FlexibleProvablePure<T>"),", which covers all SnarkyJS primitives such as ",(0,o.kt)("inlineCode",{parentName:"p"},"UInt64")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Struct({...})"),"."),(0,o.kt)("p",null,"In this case the property name ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," is used as a key in the root map. Initially the value is empty (",(0,o.kt)("inlineCode",{parentName:"p"},"Field(0)")," by default). We'll explain how data is written below."),(0,o.kt)("h4",{id:"deploying-contracts--setting-data"},"Deploying contracts & setting data"),(0,o.kt)("p",null,"The Counter contract we've seen earlier has an ",(0,o.kt)("inlineCode",{parentName:"p"},"init()")," method, which is a built-in SnarkyJS feature, that allows us to setup our on-chain state at the time of deployment. We can use the same principles to set up our off-chain state as well."),(0,o.kt)("p",null,"In order to set the initial value of our ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," off-chain state, we have to use the ",(0,o.kt)("inlineCode",{parentName:"p"},".set(value)")," method, available on ",(0,o.kt)("inlineCode",{parentName:"p"},"OffchainState"),". Once you call ",(0,o.kt)("inlineCode",{parentName:"p"},".set(...)"),", the provided value is set in the ",(0,o.kt)("inlineCode",{parentName:"p"},"@zkfs/virtual-storage"),", which ensures you can get/set values multiple times while executing your smart contract method. More importantly an event containing all the relevant information about your data write request is emitted. These events contain the ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," to your value, and the value itself. This helps us identify in which merkle map you want to update the data."),(0,o.kt)("p",null,"One of the most important concepts that ensure an eventual 100% data availability, is that the emitting of events is part of the proof/circuit itself. This means you cannot calculate a valid proof, without providing the necessary events with the required data. There are some shortcomings due to limits of data you can include in events, which we've brought up ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/o1-labs/snarkyjs/issues/757#issue-1602789987"},"here"),"."),(0,o.kt)("h4",{id:"reading-data-in-contract-methods"},"Reading data in contract methods"),(0,o.kt)("p",null,"We've already covered how you can define and set off-chain state, the next logical step is to retrieve it within our contract. You can access off-chain state by calling ",(0,o.kt)("inlineCode",{parentName:"p"},".get()")," on your defined state. In our case that would be ",(0,o.kt)("inlineCode",{parentName:"p"},"this.count.get()"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"As of current technical preview, the ContractAPI operates in an isolated test mode, which means that the data is only get/set from the virtual storage. Upcoming release of the ",(0,o.kt)("inlineCode",{parentName:"p"},"@zkfs/node")," will provide a full lifecycle experience as described in our flow diagrams above.")),(0,o.kt)("p",null,"For the sake of a simplified explanation, we assume the data required for the execution of our smart-contract method has already been pre-fetched and stored in the virtual storage."),(0,o.kt)("p",null,"Once you call ",(0,o.kt)("inlineCode",{parentName:"p"},".get()"),", the Contract API will bring in a ",(0,o.kt)("inlineCode",{parentName:"p"},"MerkleMapWitness")," for your specific map key (in our case ",(0,o.kt)("inlineCode",{parentName:"p"},"count"),"), and also the value stored under our key (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", or whatever the current state is). As a next step, the Contract API uses the received value and merkle witness to calculate a ",(0,o.kt)("strong",{parentName:"p"},"computed root hash"),", if the computed root hash matches your on-chain root-hash (",(0,o.kt)("inlineCode",{parentName:"p"},"offchainStateRootHash"),") then the data received is considered valid."),(0,o.kt)("p",null,"This was a very simplified explanation of the data correctness verification, there's a bit more to it - like making sure the on-chain root hash you're asserting against is actually the correct one. You can learn more about SnarkyJS/Mina transaction pre-conditions in the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.minaprotocol.com/zkapps/how-to-write-a-zkapp#reading-state"},"SnarkyJS docs"),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"These are the same principles as enforced by ",(0,o.kt)("inlineCode",{parentName:"p"},"@zkfs/node"),"'s consensus algorithm.")),(0,o.kt)("h3",{id:"nested-map-api"},"Nested map API"),(0,o.kt)("p",null,"We keep mentioning nested map API as it is one of the most powerful features of ZKFS's Contract API. You can find an example contract that uses it ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zkfs-io/zkfs/blob/develop/packages/examples/test/piggyBank.ts"},"here"),". The nested maps work by storing the nested map's root hash, as a value in its parent map under a specific key (map's name). This pattern allows you to store nested and complex data structures recursively, while adhering to the same cryptographic guarantees going upwards in the parent tree."),(0,o.kt)("h2",{id:"what-can-you-expect-in-the-near-future"},"What can you expect in the near future?"),(0,o.kt)("p",null,"If you'd like to explore and use ZKFS's toolkit further, please take a look at our existing ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zkfs-io/zkfs/tree/develop/packages/examples"},"examples"),", or try them in our ",(0,o.kt)("a",{parentName:"p",href:"https://stackblitz.com/github/zkfs-io/zkfs?file=packages%2Fexamples%2Ftest%2Fcounter.test.ts,packages%2Fexamples%2Ftest%2Fcounter.ts&hideExplorer=1&hideNavigation=1&theme=dark&view=editor"},"playground"),"."),(0,o.kt)("p",null,"We're also actively working on delivering all the appropriate documentation needed for you to start using ZKFS to its full potential. One of the key stepping stones in the future of ZKFS, is our ",(0,o.kt)("a",{parentName:"p",href:"https://zkignite.minaprotocol.com/zkignite/dev4dev-track-1/phase1-draftproposals/suggestion/346"},"zkIgnite funding proposal"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"If you'd like to voice your support towards ZKFS, you can do so on:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://zkignite.minaprotocol.com/zkignite/dev4dev-track-1/phase1-draftproposals/suggestion/346"},"Our zkIgnite funding proposal")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/zkfs_io"},"Our twitter")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://discord.gg/pdKS7px98G"},"Mina discord"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Thank you for reading and see you in the next blog post.")),(0,o.kt)("div",{className:"footnotes"},(0,o.kt)("hr",{parentName:"div"}),(0,o.kt)("ol",{parentName:"div"},(0,o.kt)("li",{parentName:"ol",id:"fn-1-912e90"},"As long as someone is willing to pay for the storage, and someone is willing to store it.","_",(0,o.kt)("a",{parentName:"li",href:"#fnref-1-912e90",className:"footnote-backref"},"\u21a9")))))}h.isMDXComponent=!0}}]);